[
    {
        "fileName": "Set_Matrix_Zeros",
        "data": "@app.route('/getAllDiseases')\n@cross_origin()\ndef getALlDiseases():\n    return jsonify({\"No_of_Disease\":len(categories),\"Diseases\":categories})\n\n@app.route('/', methods=['GET'])\n@cross_origin()\ndef home():\n    return app.send_static_file('index.html')",
        "topic": "Arrays"
    },
    {
        "fileName": "Pascal's_Triangle",
        "data": "## Extreme Brute Force\n- Each row = sum of index, index-1 from last row\n- Start and ends are 1\n- num of elements/columns in each row = row_number (1- based indexing)\n\n## Find element in pascals triangle at position (row,col)\n- ele at row,col = (row-1)C(col-1)\n\n\n## Finding NCR faster\n- nCr = n! / (n-r)!r! \n- 6C2 = 6! / (4!) 2! OR (6*5)/2!  [basically nr has numbers mulitiplied as many as r]\n- TC: `O(r)` as we are doing at max `r` multiplications \n- Code tips: Dont calculate nr and dr separately instead do together. But in dr start multiplying from 1*2*.....r\n\n## Code for finding at loc row,col\ndef ncr(n,r):\n    res = 1\n    for i in range(r):\n        res = res * (n-i)\n        res = res // (i+1)\n    return int(res)\n    \ndef get_pascals_ele(row, col):\n    return ncr(row-1,col-1)\n    \nprint(get_pascals_ele(3,2))",
        "topic": "Arrays"
    },
    {
        "fileName": "Next_Permutation",
        "data": "## Intuition\nThere are 3 major observations we can make between a number and its next consecutive permutation\n1. There are chances that both have most of starting numbers same - Longest prefix is expected\n   - As solution to this, we iterate L<-R and try to find misplaced element such that arr[i]<arr[i-1]\n   - Imagine this as ladder which keeps on increasing from L<-R and this element breaks that ladder\n   - We know that till arr[i-1] we keep same prefix and then have to replace arr[i] with something on the left\n- Why look for ele which is smaller than its next? if arr[i] < arr[i-1] then you can replace arr[i] and there is gauranteed to  be an element greater than arr[i]\n  - WHAT IF THERE IS NO BREAKING POINT? The curr arr is the largest permutation and next would be smallest or first permutation. So just reverse the array or sort in asc\n2. We want to replace arr[i] such that its only little greater than the current number. So replace it with lowest ele greater than arr[i] in the right side of the array. (Why smallest + greater?  we wnt next consecutive perm not largest)\n3. Now array till arr[i] is already greater than arr. Now remaining element on the right side needs to be smallest as possible (Because the arr[:i] is already greater than arr). So reverse the right side arr (or sort acc in ascending order)\n\n\n## Code\ndef nextPermutation(arr, n):\n    # find breaking point\n    break_point = -1\n    for i in reversed(range(n-1)):\n        if arr[i] < arr[i+1]:\n            break_point = i\n            break\n    \n    if break_point == -1:\n        return sorted(arr)\n\n    # replace breaking point with smallest greater\n    # check from L<-R as from right its an increasing order\n    for j in reversed(range(i+1,n)):\n        if arr[j] > arr[break_point]:\n            arr[j], arr[break_point] = arr[break_point], arr[j]\n            break\n\n    # reverse right part after breaking point\n    arr = arr[:break_point+1] + sorted(arr[break_point+1:])\n\n    return arr\n    \n    \narr = [2 ,3 ,1 ,4,5]\narr = [4,3,2,1]\narr = [5 ,6,4,2,1,3]\nres = nextPermutation(arr, len(arr))\nprint(res)",
        "topic": "Arrays"
    },
    {
        "fileName": "Kadane's_Algorithm",
        "data": "## Classical Solution\n- At each step check if csum+x is greater or x is greater\n\n## Code - Subarray Sum\ndef maxSubarraySum(arr, n):\n    csum = arr[0]\n    max_sum = arr[0]\n    for x in arr[1:]:\n        csum = max(csum+x,x)\n        max_sum = max(csum, max_sum)\n    \n    return 0 if max_sum<0 else max_sum\n\n## Code - Print Subarray Sum\ndef printMaxSubarraySum(arr, n):\n    \"\"\"\n    Return the max_subarray sum along with the range of those elements\n    Here you have to pick some ele, empty subarray is not a solution\n    \"\"\"\n    start, end = 0, 0\n    max_start, max_end = 0, 0\n    csum = arr[0]\n    max_sum = arr[0]\n    for i, x in enumerate(arr[1:]):\n        # check whats your curr start, end\n        if csum+x > x: # you include cur ele\n            end += 1\n        else: # dont include cur ele\n            start, end = i,i\n        csum = max(csum+x,x)\n        \n        if csum > max_sum: # cur start,end is better for max\n            max_start, max_end = start, end\n        max_sum = max(csum, max_sum)\n    \n    print(sum(arr[max_start:max_end+1]))\n    return max_sum, max_start, max_end\n    \n    \narr = [1 ,2 ,7 ,-4 ,3 ,2 ,-10 ,9,1] # res = 11\nprint(maxSubarraySum(arr, len(arr)))",
        "topic": "Arrays"
    },
    {
        "fileName": "Sort_an_array_of_0's,_1's_and_2's",
        "data": "## DNF Algorithm\ndef sort012(arr, n) :\n    zero_ptr = 0\n    two_ptr = n-1\n    cur = 0\n\n    while cur <= two_ptr:\n        if arr[cur] == 0:\n            arr[cur], arr[zero_ptr] = arr[zero_ptr], arr[cur]\n            cur += 1\n            zero_ptr += 1\n        elif arr[cur] == 2:\n            arr[cur], arr[two_ptr] = arr[two_ptr], arr[cur]\n            two_ptr -= 1\n        else:\n            cur += 1\n    \n    return arr",
        "topic": "Arrays"
    },
    {
        "fileName": "Stock_Buy_and_Sell",
        "data": "## You can buy and sell any number of time\n- Sell at each profit peak that you can get\n\ndef maximumProfit(arr):\n    # Write your code here.\n    res = 0\n    n = len(arr)\n    \n    for i in range(n-1):\n        if arr[i+1]>arr[i]:\n            res += (arr[i+1]-arr[i])\n    \n    return res\n\n## You can only buy and sell once\n- The max profit you can earn by selling at index `x` : `arr[x]` - `min_cost_before_i`\n\ndef maximumProfit(arr):\n    # Write your code here.\n    res = 0\n    min_till_now = float('inf')\n\n    for x in arr:\n        # max profit by selling at this day\n        res = max(res, x-min_till_now)\n\n        # check if min changes\n        min_till_now = min(min_till_now, x)\n    \n    return res",
        "topic": "Arrays"
    },
    {
        "fileName": "Rotate_Matrix",
        "data": "## CLOCKWISE\n\ndef rotateMatrixClockwise(arr, nr, nc):\n    # flip horizontally\n    for i in range(nr//2):\n        for j in range(nc):\n            # print(f\"replace {i}{j} with {nr-i-1}{j}\")\n            arr[i][j], arr[nr-i-1][j] = arr[nr-i-1][j], arr[i][j]\n    print(arr, sep=\"\\n\")\n    \n    # flip diagonally: top-left --> bottom-right\n    for i in range(nr):\n        for j in range(i+1,nc):\n            arr[i][j], arr[j][i] = arr[j][i], arr[i][j]\n    print(arr, sep=\"\\n\")\n    print()\n    \n    return arr\n    \n# INPUT\n# 1 2 3\n# 4 5 6\n# 7 8 9\n\n# OUTPUT\n# 7 4 1\n# 8 5 2\n# 9 6 3\n\n# output: [[7,4,1],[8,5,2],[9,6,3]]\narr = [[1,2,3],[4,5,6],[7,8,9]]\nrotateMatrixClockwise(arr, len(arr), len(arr))\n\n# output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\narr = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nrotateMatrixClockwise(arr, len(arr), len(arr))",
        "topic": "Arrays"
    },
    {
        "fileName": "Merge_Overlapping_Subintervals",
        "data": "def mergeIntervals(arr):\n    res = []\n    n = len(arr)\n    arr = sorted(arr)\n    \n    # always add first interval\n    res.append(arr[0])\n    \n    for x in arr[1:]:\n        cur_start, cur_end = x[0], x[1]\n        prev_start, prev_end = res[-1][0], res[-1][1]\n        \n        if cur_start <= prev_end: # cur interval can be extended\n            res[-1][1] = cur_end\n        else: # cur interval cant be extended\n            res.append(x)\n    \n    return res\n    \n\n\nintervals=[[1,3],[2,6],[8,10],[15,18]]\n# Output: [[1,6],[8,10],[15,18]]\n\nmergeIntervals(intervals)",
        "topic": "Arrays"
    },
    {
        "fileName": "Merge_two_sorted_arrays_without_extra_spac…",
        "data": "1. Do without extra space and m+n = total\n## Without extra space\n-Intution:\n  - We know that `arr1` must contain all the smaller ele and `arr2` must have larger ele\n  1. Whats the ele in `arr1` having max chance of going in `arr2`? Last ele -> since its largest in `arr1`\n  2. Whats the ele in `arr2` having max chance of going in `arr1`? first ele -> since its smallest in `arr2`\n- Solution:\n  1. pointer1: arr1[last] : start<--end\n  2. pointer2: arr2[0] : start-->end\n  3. sort and return both arr1 and arr2\n  \ndef merge_inplace(arr1, arr2):\n    n1, n2 = len(arr1), len(arr2)\n    \n    p1, p2 = n1-1, 0\n    \n    while p1>=0 and p2<n2:\n        if arr1[p1] >= arr2[p2]: # higher ele must go in arr2\n            arr1[p1], arr2[p2] = arr2[p2],arr1[p1]\n            \n        p1 -= 1\n        p2 += 1\n        \n        print(arr1, arr2, sep=\"\\n\")\n        # else: # smaller ele goes in arr1 | already in place\n        \n    \n    print(arr1, arr2, sep=\"\\n\")\n    \n\n\narr1= [1,4,8,10] \narr2 = [2,3,9]\n# print(merge_inplace(arr1, arr2))\n\n# expected\n# arr1[] = [1 2 3 4]\n# arr2[] = [8 9 10]\n\narr1= [1,3,5,7] \narr2 = [0,2,6,8,9]\nprint(merge_inplace(arr1, arr2))\n# expected\n# arr1[] = [0 1 2 3]\n# arr2[] = [5 6 7 8 9]\n\n2. Same but -> arr1 has enough space to hold M+N (extra spaced in m1 are left as 0s)\n- BRUTE FORCE\n  - remove all 0s padded in arr1. Merge arr1, arr2 in res[] and return res, arr2\n\n- OPTIMAL: No extra space\n## Without extra space\nSolution: https://leetcode.com/problems/merge-sorted-array/solutions/3436053/beats-100-best-c-java-python-and-javascript-solution-two-pointer-stl/\ndef merge_inplace(arr1, arr2, n1, n2):\n  n_last = len(arr1)-1 # includes 0s\n  i,j = n1-1, n2-1 \n  \n  while j>=0:\n    # arr1 can deplete first but arr2 cant deplete first\n    # even in first n1 times we pick from arr1, still n_last has n2 places left\n    if i>=0 and arr1[i]>=arr2[j]:\n      arr1[n_last] = arr1[i] # dont worry about swapping -> n_last we directly replace\n      i -= 1\n    else:\n      arr1[n_last] = arr2[j]\n      j -= 1\n    n_last -= 1\n\n  return arr1",
        "topic": "Arrays"
    },
    {
        "fileName": "Find_the_duplicate_in_an_array_of_N+1_inte…",
        "data": "from os import *\nfrom sys import *\nfrom collections import *\nfrom math import *\n\ndef findDuplicate(arr:list, n:int):\n    n = len(arr)\n    \n    i = 0\n    for i in range(n):\n        # print(i)\n        # already in place\n        if arr[i] == (i+1):\n            continue\n        \n        while arr[i] != (i+1):\n            correct_idx = arr[i]-1\n            cur_index = i\n            # check if correct index is already in place\n            if arr[correct_idx] == arr[cur_index]:\n                return arr[cur_index]\n            # put it in place\n            arr[cur_index], arr[correct_idx] = arr[correct_idx],arr[cur_index]\n            \n    return",
        "topic": "Arrays"
    }
]